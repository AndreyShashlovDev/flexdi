import"reflect-metadata";import e,{createContext as t,useContext as o,useState as n,useEffect as i,useRef as s,useMemo as r,useLayoutEffect as l,Suspense as a}from"react";class d{init(e){this.args=e,this.ready(e)}}var c;!function(e){e.SINGLETON="SINGLETON",e.TRANSIENT="TRANSIENT"}(c||(c={}));const u=Symbol.for("flexdi.INJECT_METADATA_KEY"),h=Symbol.for("flexdi.INJECTABLE_METADATA_KEY"),f=Symbol.for("flexdi.MODULE_METADATA_KEY"),m=Symbol.for("flexdi.SCOPE_METADATA_KEY"),p=Symbol.for("flexdi.SINGLETON_MODULE_METADATA_KEY");function v(e){const t=Reflect.getMetadata(f,e);if(!t)throw new Error(`${e.name} is not a valid module`);return t}function M(e){return!0===Reflect.getMetadata(p,e)}const g=e=>"string"==typeof e||"symbol"==typeof e?String(e):"function"==typeof e?e.name:String(e),E=e=>"string"==typeof e||"symbol"==typeof e||"function"==typeof e?e:String(e);class w{constructor(e,t,o){this.token=e,this.type=t,this.moduleRef=o,this.instance=null,this.factory=null,this.dependencies=[],this.scope=c.SINGLETON,this.sourceModule=""}async resolve(){if(this.scope===c.SINGLETON&&null!==this.instance)return this.instance;if(!this.factory)throw new Error(`Cannot resolve provider ${g(this.token)}`);const e=await Promise.all(this.dependencies.map((async e=>{try{return await this.moduleRef.resolveProvider(e)}catch(t){if(this.moduleRef.rootModule&&this.moduleRef!==this.moduleRef.rootModule)try{return await this.moduleRef.rootModule.resolveProvider(e)}catch(e){return}return}}))),t=this.dependencies.filter(((t,o)=>void 0===e[o]));if(t.length>0)throw new Error(`Cannot resolve dependencies for ${g(this.token)}: missing ${t.join(", ")}`);try{const t=this.factory(...e),o=t instanceof Promise?await t:t;return this.scope===c.SINGLETON&&(console.log("create instance",this.sourceModule,o.constructor.name),this.instance=o),o}catch(e){throw e}}dispose(){var e;(null===(e=this.instance)||void 0===e?void 0:e.onDisposeInstance)&&this.instance.onDisposeInstance(),console.log("dispose",g(this.token)),this.instance=null}}class y{constructor(e,t,o){this.options=e,this.moduleClass=t,this.isSingleton=o,this.providers=new Map,this.imports=[],this.exports=new Set,this.initialized=!1,this.initializing=!1,this.rootModule=null,this.instanceCache=new Map}get name(){return this.moduleClass.name}isExported(e){const t=E(e);return this.exports.has(t)}getLocalProvider(e){const t=E(e);return this.providers.get(t)||null}async resolveProvider(e){const t=E(e),o=this.getLocalProvider(t);if(o&&o.scope===c.TRANSIENT)return await o.resolve();if(this.instanceCache.has(t))return this.instanceCache.get(t);if(o){const e=await o.resolve();return o.scope===c.SINGLETON&&this.instanceCache.set(t,e),e}for(const e of this.imports)if(e.isExported(t))try{return await e.resolveProvider(t)}catch(e){}if(this.rootModule&&this!==this.rootModule)try{return await this.rootModule.resolveProvider(t)}catch(e){}const n=R.findParentModules(this.moduleClass);for(const e of n){const o=R.getLoadedModule(e);if(o)try{return await o.resolveProvider(t)}catch(e){}}throw new Error(`Provider ${g(t)} not found in module ${this.name}`)}async initialize(e=null){var t,o,n;if(!this.initialized)if(this.initializing)await new Promise((e=>{const t=setInterval((()=>{this.initializing||(clearInterval(t),e())}),10)}));else{this.initializing=!0;try{if(this.rootModule=e||this,null===(t=this.options.imports)||void 0===t?void 0:t.length)for(const e of this.options.imports){let t=R.getLoadedModule(e);if(!t){const o=M(e);t=new y(v(e),e,o),await t.initialize(this.rootModule),R.registerModule(e,t)}if(this.imports.push(t),this.options.exports)for(const e of this.options.exports){const o=E(e);if(t.isExported(o)&&!this.providers.has(o)){const e=new w(o,"token",this);e.sourceModule=t.name,e.factory=()=>this.instanceCache.get(o),e.scope=c.SINGLETON,this.providers.set(o,e),this.instanceCache.set(o,await t.resolveProvider(o))}}}if(null===(o=this.options.providers)||void 0===o?void 0:o.length)for(const e of this.options.providers)await this.registerProvider(e);if(null===(n=this.options.exports)||void 0===n?void 0:n.length)for(const e of this.options.exports){const t=E(e);if(this.exports.add(t),!this.providers.has(t)){let e=!1;for(const o of this.imports)if(o.isExported(t)){e=!0;const n=new w(t,"token",this);n.sourceModule=o.name,n.factory=()=>this.instanceCache.get(t),n.scope=c.SINGLETON,this.providers.set(t,n),this.instanceCache.set(t,await o.resolveProvider(t));break}e||console.warn(`Module ${this.name} exports token ${g(t)} not found`)}}await this.preInitializeExports(),this.initialized=!0}finally{this.initializing=!1}}}async preInitializeExports(){for(const e of this.exports)if(!this.instanceCache.has(e))try{const t=this.providers.get(e);if(t){const o=await t.resolve();this.instanceCache.set(e,o)}}catch(t){console.error(`Failed to pre-initialize export ${g(e)}`)}}async registerProvider(e){var t;const o=E(e.provide);if(this.providers.has(o))return;const n=new w(o,"class",this);if(n.sourceModule=this.name,"useClass"in e){const t=e,i=t.useClass;n.scope=t.scope||function(e){return Reflect.getMetadata(m,e)||null}(i)||c.SINGLETON;const s=function(e){try{const t=Reflect.getMetadata(u,e)||{},o=Object.keys(t).length>0?Math.max(...Object.keys(t).map(Number)):-1,n=new Array(o+1).fill(null);for(const[e,o]of Object.entries(t))n[Number(e)]=o;return n}catch(t){return console.warn(`Failed to get tokens for ${null==e?void 0:e.name}`),[]}}(i);n.dependencies=s.map((e=>E(e)));const r=[];for(const e of n.dependencies){const t=this.providers.has(e);let o=!1;for(const t of this.imports)if(t.isExported(e)){o=!0;break}const n=this.rootModule!==this&&null!==this.rootModule&&this.rootModule.providers.has(e);t||o||n||r.push(e)}if(r.length>0){const e=r.map((e=>"function"==typeof e?e.name:String(e))).join(", ");throw new Error(`Cannot register provider ${g(o)} (${i.name}) in module ${this.name}: missing dependencies [${e}]. Make sure all dependencies are available through the module's providers, imports, or root module.`)}n.factory=(...e)=>new i(...e)}else if("useValue"in e){const t=e;n.type="value",n.scope=c.SINGLETON,n.instance=t.useValue}else if("useFactory"in e){const t=e;n.type="factory",n.scope=c.SINGLETON,t.deps&&(n.dependencies=t.deps.map((e=>E(e)))),n.factory=(...e)=>t.useFactory(...e)}else if("useToken"in e){const t=e;n.type="token",n.scope=c.SINGLETON,n.dependencies=[E(t.useToken)],n.factory=e=>e}if(this.providers.set(o,n),null===(t=this.options.exports)||void 0===t?void 0:t.some((e=>E(e)===o)))try{const e=await n.resolve();this.instanceCache.set(o,e)}catch(e){console.error(`Failed to pre-initialize provider ${g(o)}`)}}dispose(){for(const e of this.providers.values())console.log("dispose provider",this.moduleClass.name,g(e.token),null!==e.instance),e.dispose();this.providers.clear(),this.exports.clear(),this.imports=[],this.initialized=!1,this.rootModule=null,this.instanceCache.clear()}}class C{constructor(){this.moduleRefs=new Map,this.singletonModuleRefs=new Map,this.rootModuleRef=null,this.moduleImports=new Map,this.initializationPromises=new Map}registerModule(e,t){if(t.isSingleton?this.singletonModuleRefs.has(e.name)||this.singletonModuleRefs.set(e.name,t):this.moduleRefs.set(e.name,t),t.options.imports)for(const o of t.options.imports)this.moduleImports.has(o.name)||this.moduleImports.set(o.name,new Set),this.moduleImports.get(o.name).add(e.name)}isRootModule(e){var t;return(null===(t=this.rootModuleRef)||void 0===t?void 0:t.moduleClass)===e}findParentModules(e){const t=this.moduleImports.get(e.name)||new Set,o=[];for(const e of t){const t=this.moduleRefs.get(e);(null==t?void 0:t.moduleClass)&&o.push(t.moduleClass)}return o}getLoadedModule(e){var t,o;return null!==(o=null!==(t=this.moduleRefs.get(e.name))&&void 0!==t?t:this.singletonModuleRefs.get(e.name))&&void 0!==o?o:null}isModuleLoaded(e){const t=this.getLoadedModule(e);return!!t&&t.initialized}async loadModule(e,t=!1){if(this.isModuleLoaded(e))return new e;const o=this.initializationPromises.get(e.name);if(o)return await o,new e;const n=M(e),i=v(e),s=new y(i,e,n);let r;t?(this.rootModuleRef=s,r=s.initialize(s)):r=s.initialize(this.rootModuleRef),this.initializationPromises.set(e.name,r);try{return await r,this.registerModule(e,s),new e}finally{this.initializationPromises.delete(e.name)}}getService(e,t){var o,n;const i=this.getLoadedModule(e);if(!i)throw new Error(`Module ${e.name} not loaded`);const s=E(t);if(!i.isExported(s)){if(null===(o=this.rootModuleRef)||void 0===o?void 0:o.instanceCache.has(s))return this.rootModuleRef.instanceCache.get(s);throw new Error(`Token ${g(s)} not exported from module ${e.name}`)}if(i.instanceCache.has(s))return i.instanceCache.get(s);if(null===(n=this.rootModuleRef)||void 0===n?void 0:n.instanceCache.has(s))return this.rootModuleRef.instanceCache.get(s);throw new Error(`Provider ${g(s)} not pre-initialized in module ${e.name}`)}unloadModule(e){const t=this.getLoadedModule(e);if(!t||t.isSingleton)return;if(t===this.rootModuleRef)return void console.warn("Cannot unload root module");const o=this.findDependentModules(e);if(o.length>0)console.warn(`Cannot unload module ${e.name}, still imported by: ${o.join(", ")}`);else{t.dispose(),this.moduleRefs.delete(e.name),this.moduleImports.delete(e.name);for(const t of this.moduleImports.values())t.delete(e.name);if(t.options.imports)for(const e of t.options.imports)0===this.findDependentModules(e).length&&(console.log("unload imports",e.name),this.unloadModule(e))}}findDependentModules(e){const t=[];for(const[o,n]of this.moduleRefs.entries())n.imports.some((t=>t.moduleClass.name===e.name))&&t.push(o);return t}}const R=new C,N=async(e,t)=>{await R.loadModule(e,t)};function S(e){return t=>{Reflect.defineMetadata(f,e,t)}}function L(e=c.SINGLETON){return t=>{Reflect.defineMetadata(h,!0,t),Reflect.defineMetadata(m,e,t)}}function T(e){return(t,o,n)=>{const i=Reflect.getMetadata(u,t)||{};i[n]=e,Reflect.defineMetadata(u,i,t)}}function I(){return e=>{Reflect.defineMetadata(p,!0,e)}}const x=t(null);function P(){const e=o(x);if(!e)throw new Error("useCurrentModule must be used within ModuleProvider");return e.moduleClass}function b(e,t){const[o,s]=n(t);return i((()=>{const t=null==e?void 0:e.subscribe({next:s});return()=>null==t?void 0:t.unsubscribe()}),[e]),o}const $="production"===process.env.NODE_ENV;function k(e,t){const o=P(),n=s(!1),i=s(0),a=r((()=>{try{return R.getService(o,e)}catch(t){throw console.warn(`Could not resolve presenter ${String(e)} from module ${o.name}, trying root container...`,t),t}}),[o,e]);return l((()=>{i.current++;const e=i.current;return(e===($?1:2)||n.current)&&(a.init(t),n.current=!0),()=>{(e===($?1:2)||n.current)&&(a.destroy(),i.current=0)}}),[a,e,JSON.stringify(t),o]),a}function z(e){const t=P();return r((()=>R.getService(t,e)),[t,e])}const O=({module:t,children:o,LoadingComponent:r,ErrorComponent:l,isRootModule:a=!1})=>{const d=s(!1),[c,u]=n(R.isModuleLoaded(t)),[h,f]=n(null);return i((()=>{if(d.current)return;let e=!0;return d.current=!0,N(t,a).then((()=>{u(!0)})).catch((o=>{u(!1),e&&(console.error("Error loading module:",t.name,o),f(o instanceof Error?o:new Error(String(o))))})),()=>{e=!1,u(!1),d.current=!1,R.unloadModule(t)}}),[t]),h?e.createElement(l,null):c?e.createElement(e.Fragment,null,o):e.createElement(r,null)},A=({module:t,children:o})=>(i((()=>{let e=!0;return(async()=>{try{R.isModuleLoaded(t)||await R.loadModule(t)}catch(o){e&&console.error(`Error loading module ${t.name}:`,o)}})(),()=>{e=!1}}),[t]),e.createElement(x.Provider,{value:{moduleClass:t}},o));function G({path:t,module:o,Component:n,ErrorBoundary:i,LoadingComponent:s,ErrorComponent:r}){return{path:t,element:e.createElement(i,{fallback:e.createElement(r,null)},e.createElement(a,{fallback:e.createElement(s,null)},e.createElement(O,{key:t,module:o,LoadingComponent:s,ErrorComponent:r,isRootModule:!1},e.createElement(A,{module:o},e.createElement(n,null)))))}}function D({module:e,children:t,ErrorBoundary:o,LoadingComponent:n,ErrorComponent:i}){return _({module:e,children:t,ErrorBoundary:o,LoadingComponent:n,ErrorComponent:i,isRootModule:!0})}function _({module:t,children:o,ErrorBoundary:n,LoadingComponent:i,ErrorComponent:s,isRootModule:r=!1}){return e.createElement(n,{fallback:e.createElement(s,null)},e.createElement(a,{fallback:e.createElement(i,null)},e.createElement(O,{module:t,LoadingComponent:i,ErrorComponent:s,isRootModule:r},e.createElement(x.Provider,{value:{moduleClass:t}},o))))}export{d as BasicPresenter,h as INJECTABLE_METADATA_KEY,u as INJECT_METADATA_KEY,T as Inject,L as Injectable,f as MODULE_METADATA_KEY,S as Module,x as ModuleContext,O as ModuleGuard,_ as ModuleLoader,C as ModuleManager,A as ModuleProvider,y as ModuleRef,w as ProviderRef,D as RootModuleLoader,m as SCOPE_METADATA_KEY,p as SINGLETON_MODULE_METADATA_KEY,c as Scope,I as Singleton,G as createModuleRoute,g as getTokenDebugName,E as getTokenName,R as moduleManager,N as preloadModule,P as useCurrentModule,z as useInject,b as useObservable,k as usePresenter};
//# sourceMappingURL=index.esm.js.map
