import"reflect-metadata";class e{init(e){this.args=e,this.ready(e)}}var t;!function(e){e.SINGLETON="SINGLETON",e.TRANSIENT="TRANSIENT"}(t||(t={}));const o=Symbol.for("flexdi.INJECT_METADATA_KEY"),i=Symbol.for("flexdi.INJECTABLE_METADATA_KEY"),s=Symbol.for("flexdi.MODULE_METADATA_KEY"),n=Symbol.for("flexdi.SCOPE_METADATA_KEY"),r=Symbol.for("flexdi.SINGLETON_MODULE_METADATA_KEY");function a(e){const t=Reflect.getMetadata(s,e);if(!t)throw new Error(`${e.name} is not a valid module`);return t}function l(e){return!0===Reflect.getMetadata(r,e)}const d=e=>"string"==typeof e||"symbol"==typeof e?String(e):"function"==typeof e?e.name:String(e),c=e=>"string"==typeof e||"symbol"==typeof e||"function"==typeof e?e:String(e);class h{constructor(e,o,i){this.token=e,this.type=o,this.moduleRef=i,this.instance=null,this.factory=null,this.dependencies=[],this.scope=t.SINGLETON,this.sourceModule=""}async resolve(){if(this.scope===t.SINGLETON&&null!==this.instance)return this.instance;if(!this.factory)throw new Error(`Cannot resolve provider ${d(this.token)}`);const e=await Promise.all(this.dependencies.map((async e=>{try{return await this.moduleRef.resolveProvider(e)}catch(t){if(this.moduleRef.rootModule&&this.moduleRef!==this.moduleRef.rootModule)try{return await this.moduleRef.rootModule.resolveProvider(e)}catch(e){return}return}}))),o=this.dependencies.filter(((t,o)=>void 0===e[o]));if(o.length>0)throw new Error(`Cannot resolve dependencies for ${d(this.token)}: missing ${o.join(", ")}`);try{const o=this.factory(...e),i=o instanceof Promise?await o:o;return this.scope===t.SINGLETON&&(this.instance=i),i}catch(e){throw e}}dispose(){var e;(null===(e=this.instance)||void 0===e?void 0:e.onDisposeInstance)&&this.instance.onDisposeInstance(),this.instance=null}}class u{constructor(e,t,o){this.options=e,this.moduleClass=t,this.isSingleton=o,this.providers=new Map,this.imports=[],this.exports=new Set,this.initialized=!1,this.initializing=!1,this.rootModule=null,this.instanceCache=new Map}get name(){return this.moduleClass.name}isExported(e){const t=c(e);return this.exports.has(t)}getLocalProvider(e){const t=c(e);return this.providers.get(t)||null}async resolveProvider(e){const o=c(e),i=this.getLocalProvider(o);if(i&&i.scope===t.TRANSIENT)return await i.resolve();if(this.instanceCache.has(o))return this.instanceCache.get(o);if(i){const e=await i.resolve();return i.scope===t.SINGLETON&&this.instanceCache.set(o,e),e}for(const e of this.imports)if(e.isExported(o))try{return await e.resolveProvider(o)}catch(e){}if(this.rootModule&&this!==this.rootModule)try{return await this.rootModule.resolveProvider(o)}catch(e){}const s=p.findParentModules(this.moduleClass);for(const e of s){const t=p.getLoadedModule(e);if(t)try{return await t.resolveProvider(o)}catch(e){}}throw new Error(`Provider ${d(o)} not found in module ${this.name}`)}async initialize(e=null){var o,i,s;if(!this.initialized)if(this.initializing)await new Promise((e=>{const t=setInterval((()=>{this.initializing||(clearInterval(t),e())}),10)}));else{this.initializing=!0;try{if(this.rootModule=e||this,null===(o=this.options.imports)||void 0===o?void 0:o.length)for(const e of this.options.imports){let o=p.getLoadedModule(e);if(!o){const t=l(e);o=new u(a(e),e,t),await o.initialize(this.rootModule),p.registerModule(e,o)}if(this.imports.push(o),this.options.exports)for(const e of this.options.exports){const i=c(e);if(o.isExported(i)&&!this.providers.has(i)){const e=new h(i,"token",this);e.sourceModule=o.name,e.factory=()=>this.instanceCache.get(i),e.scope=t.SINGLETON,this.providers.set(i,e),this.instanceCache.set(i,await o.resolveProvider(i))}}}if(null===(i=this.options.providers)||void 0===i?void 0:i.length)for(const e of this.options.providers)await this.registerProvider(e);if(null===(s=this.options.exports)||void 0===s?void 0:s.length)for(const e of this.options.exports){const o=c(e);if(this.exports.add(o),!this.providers.has(o)){let e=!1;for(const i of this.imports)if(i.isExported(o)){e=!0;const s=new h(o,"token",this);s.sourceModule=i.name,s.factory=()=>this.instanceCache.get(o),s.scope=t.SINGLETON,this.providers.set(o,s),this.instanceCache.set(o,await i.resolveProvider(o));break}e||console.warn(`Module ${this.name} exports token ${d(o)} not found`)}}await this.preInitializeExports(),this.initialized=!0}finally{this.initializing=!1}}}async preInitializeExports(){for(const e of this.exports)if(!this.instanceCache.has(e))try{const t=this.providers.get(e);if(t){const o=await t.resolve();this.instanceCache.set(e,o)}}catch(t){console.error(`Failed to pre-initialize export ${d(e)}`)}}async registerProvider(e){var i;const s=c(e.provide);if(this.providers.has(s))return;const r=new h(s,"class",this);if(r.sourceModule=this.name,"useClass"in e){const i=e,a=i.useClass;r.scope=i.scope||function(e){return Reflect.getMetadata(n,e)||null}(a)||t.SINGLETON;const l=function(e){try{const t=Reflect.getMetadata(o,e)||{},i=Object.keys(t).length>0?Math.max(...Object.keys(t).map(Number)):-1,s=new Array(i+1).fill(null);for(const[e,o]of Object.entries(t))s[Number(e)]=o;return s}catch(t){return console.warn(`Failed to get tokens for ${null==e?void 0:e.name}`),[]}}(a);r.dependencies=l.map((e=>c(e)));const h=[];for(const e of r.dependencies){const t=this.providers.has(e);let o=!1;for(const t of this.imports)if(t.isExported(e)){o=!0;break}const i=this.rootModule!==this&&null!==this.rootModule&&this.rootModule.providers.has(e);t||o||i||h.push(e)}if(h.length>0){const e=h.map((e=>"function"==typeof e?e.name:String(e))).join(", ");throw new Error(`Cannot register provider ${d(s)} (${a.name}) in module ${this.name}: missing dependencies [${e}]. Make sure all dependencies are available through the module's providers, imports, or root module.`)}r.factory=(...e)=>new a(...e)}else if("useValue"in e){const o=e;r.type="value",r.scope=t.SINGLETON,r.instance=o.useValue}else if("useFactory"in e){const o=e;r.type="factory",r.scope=t.SINGLETON,o.deps&&(r.dependencies=o.deps.map((e=>c(e)))),r.factory=(...e)=>o.useFactory(...e)}else if("useToken"in e){const o=e;r.type="token",r.scope=t.SINGLETON,r.dependencies=[c(o.useToken)],r.factory=e=>e}if(this.providers.set(s,r),null===(i=this.options.exports)||void 0===i?void 0:i.some((e=>c(e)===s)))try{const e=await r.resolve();this.instanceCache.set(s,e)}catch(e){console.error(`Failed to pre-initialize provider ${d(s)}`)}}dispose(){for(const e of this.providers.values())e.dispose();this.providers.clear(),this.exports.clear(),this.imports=[],this.initialized=!1,this.rootModule=null,this.instanceCache.clear()}}class f{constructor(){this.moduleRefs=new Map,this.singletonModuleRefs=new Map,this.rootModuleRef=null,this.moduleImports=new Map,this.initializationPromises=new Map}registerModule(e,t){if(t.isSingleton?this.singletonModuleRefs.has(e.name)||this.singletonModuleRefs.set(e.name,t):this.moduleRefs.set(e.name,t),t.options.imports)for(const o of t.options.imports)this.moduleImports.has(o.name)||this.moduleImports.set(o.name,new Set),this.moduleImports.get(o.name).add(e.name)}isRootModule(e){var t;return(null===(t=this.rootModuleRef)||void 0===t?void 0:t.moduleClass)===e}findParentModules(e){const t=this.moduleImports.get(e.name)||new Set,o=[];for(const e of t){const t=this.moduleRefs.get(e);(null==t?void 0:t.moduleClass)&&o.push(t.moduleClass)}return o}getLoadedModule(e){var t,o;return null!==(o=null!==(t=this.moduleRefs.get(e.name))&&void 0!==t?t:this.singletonModuleRefs.get(e.name))&&void 0!==o?o:null}isModuleLoaded(e){const t=this.getLoadedModule(e);return!!t&&t.initialized}async loadModule(e,t=!1){if(this.isModuleLoaded(e))return new e;const o=this.initializationPromises.get(e.name);if(o)return await o,new e;const i=l(e),s=a(e),n=new u(s,e,i);let r;t?(this.rootModuleRef=n,r=n.initialize(n)):r=n.initialize(this.rootModuleRef),this.initializationPromises.set(e.name,r);try{return await r,this.registerModule(e,n),new e}finally{this.initializationPromises.delete(e.name)}}getService(e,t){var o,i;const s=this.getLoadedModule(e);if(!s)throw new Error(`Module ${e.name} not loaded`);const n=c(t);if(!s.isExported(n)){if(null===(o=this.rootModuleRef)||void 0===o?void 0:o.instanceCache.has(n))return this.rootModuleRef.instanceCache.get(n);throw new Error(`Token ${d(n)} not exported from module ${e.name}`)}if(s.instanceCache.has(n))return s.instanceCache.get(n);if(null===(i=this.rootModuleRef)||void 0===i?void 0:i.instanceCache.has(n))return this.rootModuleRef.instanceCache.get(n);throw new Error(`Provider ${d(n)} not pre-initialized in module ${e.name}`)}unloadModule(e){const t=this.getLoadedModule(e);if(!t||t.isSingleton)return;if(t===this.rootModuleRef)return void console.warn("Cannot unload root module");const o=this.findDependentModules(e);if(o.length>0)console.warn(`Cannot unload module ${e.name}, still imported by: ${o.join(", ")}`);else{t.dispose(),this.moduleRefs.delete(e.name),this.moduleImports.delete(e.name);for(const t of this.moduleImports.values())t.delete(e.name);if(t.options.imports)for(const e of t.options.imports)0===this.findDependentModules(e).length&&this.unloadModule(e)}}findDependentModules(e){const t=[];for(const[o,i]of this.moduleRefs.entries())i.imports.some((t=>t.moduleClass.name===e.name))&&t.push(o);return t}}const p=new f,m=async(e,t)=>{await p.loadModule(e,t)};function v(e){return t=>{Reflect.defineMetadata(s,e,t)}}function M(e=t.SINGLETON){return t=>{Reflect.defineMetadata(i,!0,t),Reflect.defineMetadata(n,e,t)}}function g(e){return(t,i,s)=>{const n=Reflect.getMetadata(o,t)||{};n[s]=e,Reflect.defineMetadata(o,n,t)}}function w(){return e=>{Reflect.defineMetadata(r,!0,e)}}export{e as BasicPresenter,i as INJECTABLE_METADATA_KEY,o as INJECT_METADATA_KEY,g as Inject,M as Injectable,s as MODULE_METADATA_KEY,v as Module,f as ModuleManager,u as ModuleRef,h as ProviderRef,n as SCOPE_METADATA_KEY,r as SINGLETON_MODULE_METADATA_KEY,t as Scope,w as Singleton,c as getTokenName,p as moduleManager,m as preloadModule};
//# sourceMappingURL=index.js.map
